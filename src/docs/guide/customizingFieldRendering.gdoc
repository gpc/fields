The plugin resolves the GSP template used for each property according to conventions. You can override the rendering based on the class and property name or the property type. The _f:field_ tag looks for a template called @\_field.gsp@, the _f:input_ tag looks for a template called @\_input.gsp@ and the _f:display_ tag looks for a template called @\_display.gsp@. 

Since version 1.5: 
* You can add a template @\_layout.gsp@ that wraps/decorate the markup generated by @\_field.gsp@ or @\_display.gsp@ (layouts are ignored by @\_input.gsp@). See the "Layout" section below for more details.
* You can define component templates and use them for different fields, to avoid duplicating field templates. See the "Component" section below for more details.

All the tags will look in the following locations in decreasing order of preference:

# @grails-app/views/\_components/*componentName*/@
# @grails-app/views/*controllerName*/*actionName*/*propertyName*/@
# @grails-app/views/*controllerName*/*actionName*/*propertyType*/@
# @grails-app/views/*controllerName*/*actionName*/@
# @grails-app/views/*controllerName*/*propertyName*/@
# @grails-app/views/*controllerName*/*propertyType*/@
# @grails-app/views/*controllerName*/@
# @grails-app/views/\_fields/*class*/*propertyName*/@
# @grails-app/views/\_fields/*superclass*/*propertyName*/@
# @grails-app/views/\_fields/*associationType*/@
# @grails-app/views/\_fields/*propertyType*/@
# @grails-app/views/\_fields/*propertySuperclass*/@
# @grails-app/views/\_fields/default/@

The variables referenced in these paths are:

{table}
*Name* | *Description*
*componentName* | The value of the component attribute provided to _f:field_ or _f:display_
*controllerName* | The name of the current controller (if any).
*actionName* | The name of the current action (if any).
*class* | The bean class. For simple properties this is the class of the object passed to the _bean_ attribute of the _f:field_ or _f:input_ tag but when the _property_ attribute was nested this is the class at the end of the chain. For example, if the property path was _employees\[0\].address.street_ this will be the class of _address_.
*superclass* | Any superclass or interface of _class_ excluding _Object_, _GroovyObject_, _Serializable_, _Comparable_ and _Cloneable_.
*propertyName* | The property name at the end of the chain passed to the _property_ attribute of the _f:field_ or _f:input_ tag. For example, if the property path was _employees\[0\].address.street_ then this will be _street_.
*propertyType* | The type of the property at the end of the chain passed to the _property_ attribute of the _f:field_ or _f:input_ tag. For example, for a _java.lang.String_ property this would be _string_.
*propertySuperclass* | Any superclass or interface of _propertyType_ excluding _Object_, _GroovyObject_, _Serializable_, _Comparable_ and _Cloneable_.
*associationType* | One of _'oneToOne'_, _'oneToMany'_, _'manyToMany'_ or _'manyToOne'_. Only relevant if the property is a domain class association.
{table}

All class names are camel-cased simple forms. For example _java.lang.String_ = _string_, _com.project.HomeAddress_ = _homeAddress_.

Templates are resolved in this order so that you can override in the more specific circumstance and fall back to successively more general defaults. For example, you can define a field template for all _java.lang.String_ properties but override a specific property of a particular class to use more specialized rendering.

Templates in plugins are resolved as well. This means plugins such as _Joda Time_ can provide default rendering for special property types. A template in your application will take precedence over a template in a plugin at the same 'level'. For example if a plugin provides a @grails-app/views/\_fields/string/\_input.gsp@ the same template in your application will override it but if the plugin provides @grails-app/views/\_fields/person/name/\_input.gsp@ it would be used in preference to the more general template in your application.

For most properties the out-of-the-box defaults should provide a good starting point.

h2. Layout
Since version 1.5 you can reduce duplicate markup by defining one template for the input itself and another for
the layout, i.e. the rest of a field's markup. Prior to version 1.5 a typical field template would look something like:

{code}
<div class="person-field">
    <label>${label}</label>

    <input type="text" name="${prefix}${property}" value="${value}"/>

    <g:if test="${required}"> <span class="required-indicator">*</span> </g:if>
</div>
{code}

Now you can separate the markup for the input itself and the layout, e.g.

Layout template:

{code}
<div class="person-field">
    <label>${label}</label>

    ${raw(renderedField)}

    <g:if test="${required}"> <span class="required-indicator">*</span> </g:if>
</div>
{code}

Input template:

{code}
<input type="text" name="${prefix}${property}" value="${value}"/>
{code}

{note}
You can specify a default layout in @_fields/default/_layout.gsp@.
{note}

A layout named @foo@ will be generated from a template located at @_fields/_layouts/_foo.gsp@.

Example:
{code}
<f:field bean="travel" property="startDate" layout="specialLayout"/>

<f:with bean="person" layout="specialLayout">
  <f:field property="name"/>
  <f:field property="birthday"/>
  <f:field property="gender" layout="layoutX"/>
</f:with>
{code}

{note}
The @name@ and @birthday@ properties will use @specialLayout@ and the @gender@ property will use @layoutX@.
{note}

Separating the markup for the input itself and the rest of the field (layout) into different templates avoids the need to duplicate
the layout markup for different input types.

{note}
The introduction of this feature in version 1.5 may break any pre-existing field templates. To avoid this,
create a default layout @_fields/_default/_layout.gsp@ that renders only the contents of the field
{code}${raw(renderedField)}{code}
{note}

h2. Component
You can force a particular template to be used for field rendering via the _component_ attribute. For example,
given the markup below, the @_fields/_components/time/_field.gsp@ template will be used to render the startTime and arrivalTime fields.

{code}
<f:with bean="travel">
    <f:field property="startTime" component="time"/>
    <f:field property="arrivalTime" component="time"/>
</f:with>
{code}

h2. Example

Given an object of class _Employee_ that extends the class _Person_ and has a String _name_ property.

You can override the template _f:field_ uses with any of these:

# @grails-app/views/\_fields/\_components/*componentName*/\_field.gsp@
# @grails-app/views/*controllerName*/*actionName*/name/\_field.gsp@
# @grails-app/views/*controllerName*/*actionName*/string/\_field.gsp@
# @grails-app/views/*controllerName*/*actionName*/\_field.gsp@
# @grails-app/views/*controllerName*/name/\_field.gsp@
# @grails-app/views/*controllerName*/string/\_field.gsp@
# @grails-app/views/*controllerName*/\_field.gsp@
# @grails-app/views/\_fields/employee/name/\_field.gsp@
# @grails-app/views/\_fields/person/name/\_field.gsp@
# @grails-app/views/\_fields/string/\_field.gsp@
# @grails-app/views/\_fields/default/\_field.gsp@

override the template _f:input_ uses with any of these:

# @grails-app/views/\_fields/\_components/*componentName*/\_input.gsp@
# @grails-app/views/*controllerName*/*actionName*/name/\_input.gsp@
# @grails-app/views/*controllerName*/*actionName*/string/\_input.gsp@
# @grails-app/views/*controllerName*/*actionName*/\_input.gsp@
# @grails-app/views/*controllerName*/name/\_input.gsp@
# @grails-app/views/*controllerName*/string/\_input.gsp@
# @grails-app/views/*controllerName*/\_input.gsp@
# @grails-app/views/\_fields/employee/name/\_input.gsp@
# @grails-app/views/\_fields/person/name/\_input.gsp@
# @grails-app/views/\_fields/string/\_input.gsp@
# @grails-app/views/\_fields/default/\_input.gsp@

and override the template _f:display_ uses with any of these:

# @grails-app/views/\_fields/\_components/*componentName*/\_display.gsp@
# @grails-app/views/*controllerName*/*actionName*/name/\_display.gsp@
# @grails-app/views/*controllerName*/*actionName*/string/\_display.gsp@
# @grails-app/views/*controllerName*/*actionName*/\_display.gsp@
# @grails-app/views/*controllerName*/name/\_display.gsp@
# @grails-app/views/*controllerName*/string/\_display.gsp@
# @grails-app/views/*controllerName*/\_display.gsp@
# @grails-app/views/\_fields/employee/name/\_display.gsp@
# @grails-app/views/\_fields/person/name/\_display.gsp@
# @grails-app/views/\_fields/string/\_display.gsp@
# @grails-app/views/\_fields/default/\_display.gsp@

During template development it is usually recommended to disable template caching in order to allow the plugin to recognize new/renamed/moved templates without restarting the application. See the "Performance" section of the guide for the exact settings.

h2. Default Behaviour - Using Grails Input Tags

If no template override is found the plugin will use the standard grails input tags (e.g. _g:select_, _g:checkbox_, _g:field_) for rendering input controls.
Using _f:field_ you can pass extra arguments (e.g. _optionKey_, _optionValue_) through to these tags by prefixing them with @input-@, e.g.

{code}
<f:field bean="person" property="gender" input-optionValue="name"/>
{code}

h2. Template parameters

The _f:field_ and _f:input_ tags will pass the following parameters to your templates or to the body of _f:field_ if you use one:

{table}
*Name* | *Type* | *Description*
*bean* | Object | The _bean_ attribute as passed to the _f:field_ or _f:input_ tag.
*property* | String | The _property_ attribute as passed to the _f:field_ or _f:input_ tag. This would generally be useful for the _name_ attribute of a form input.
*type* | Class | The property type.
*label* | String | The field label text. This is based on the _label_ attribute passed to the _f:field_ or _f:input_ tag. If no _label_ attribute was used the label is resolved by convention - see below.
*value* | Object | the property value. This can also be overridden or defaulted if the _value_ or _default_ attribute was passed to _f:field_ or _f:input_.
*constraints* | ConstrainedProperty | The constraints for the property if the bean is a domain or command object.
*persistentProperty* | GrailsDomainClassProperty | The persistent property object if the bean is a domain object.
*errors* | List<String> | The error messages for any field errors present on the property. If there are no errors this will be an empty _List_.
*required* | boolean | _true_ if the field is required, i.e. has a @nullable: false@ or @blank: false@ constraint.
*invalid* | boolean | _true_ if the property has any field errors.
*prefix* | String | A string (including the trailing period) that should be appended before the input name such as @name="${prefix}propertyName"@.  The label is also modified.
{table}

In addition _f:field_ passes the following parameters:

{table}
*Name* | *Type* | *Description*
*widget* | String | The output of _f:input_ for the current bean and property if _f:field_ was used without a tag body, otherwise the output of the tag body.
{table}

To use in the layout's template:

{table}
*Name* | *Type* | *Description*
*renderedField* | String | The output of the component.
{table}

{note}
If the _bean_ attribute was not supplied to _f:field_ then _bean_, _type_, _value_ and _persistentProperty_ will all be _null_.
{note}

h3. Field labels

If the _label_ attribute is not supplied to the _f:field_ tag then the label string passed to the field template is resolved by convention. The plugin uses the following order of preference for the label:

# An i18n message using the key '_beanClass_._path_@.label@'. For example when using @<f:field bean="personInstance" property="address.city"/>@ the plugin will try the i18n key @person.address.city.label@. If the property path contains any index it is removed so @<f:field bean="authorInstance" property="books[0].title"/>@ would use the key @author.books.title.label@.
# An i18n message using the key '_objectType_._propertyName_@.label@'. For example when using @<f:field bean="personInstance" property="address.city"/>@ the plugin will try the i18n key @address.city.label@.
# The natural property name. For example when using @<f:field bean="personInstance" property="dateOfBirth"/>@ the plugin will use the label @"Date Of Birth"@.